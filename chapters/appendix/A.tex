\chapter{Objective functions and geometry loading in LBM}\label{appendix A}

\subsection*{Loading the geometry}
The following reads an automatically generated \texttt{.txt} file with the prescribed dimensions of the lattice meant to be used in a simulation.
\begin{lstlisting}[
	language=C++,
	caption={Implementation of loading the dimensions of the domain.},
	label={lst:calculateVelocityGradient}]
std::ifstream infile("path_to_dimensions" + fname);
int X_given, Y_given, Z_given, X, Y, Z;

while (infile >> X_given >> Y_given >> Z_given)
{
	X = X_given;
	Y = Y_given;
	Z = Z_given;
}
\end{lstlisting}

The following function reads a \texttt{.txt} file generated by geometry generation process and assigns corresponding types to the lattice nodes.

\begin{lstlisting}[
	language=C++,
	caption={Implementation of the \texttt{generateObject} function for geometry initialization.},
	label={lst:generateObject}]
void generateObject()
{
	for (int x = 0; x < globX; x++) {
		for (int y = 0; y < globY; y++) {
			for (int z = 0; z < globZ; z++) {
				near_wall[POS(x, y, z, globX, globY, globZ)] = 0;
			}
		}
	}
	
	std::ifstream infile("path_to_geometry" + fname);
	int x, y, z, type;
	
	while (infile >> x >> y >> z >> type) {
		// Assign based on type
		if (type == 0) {
			nse.setMap(x, y, z, BC::GEO_NOTHING);
			wall_type[POS(x, y, z, globX, globY, globZ)] = 0;
		}
		// Additional conditions include assignment of fluid cells,
		// outflow cells, inflow cells, etc. Omitted for brevity...
	}
}
\end{lstlisting}

\subsection*{Velocity gradient calculation}
This function calculates the velocity gradient at a given point within the simulation domain. It uses finite difference scheme, where either one-sided or central difference is used based on the position of the point relative to a wall.
\begin{lstlisting}[
	language=C++,
	caption={Implementation of the \texttt{calculateVelocityGradient} function for velocity gradient calculation.},
	label={lst:calculateVelocityGradient}]
velocityGradient calculateVelocityGradient(idx x, idx y, idx z)
{
	velocityGradient dV{};
	
	if (wall_type[POS(x, y, z, globX, globY, globZ)] != 1) {
		dV.V11 = dV.V12 = dV.V13 = no0;
		dV.V21 = dV.V22 = dV.V23 = no0;
		dV.V31 = dV.V32 = dV.V33 = no0;
		return dV;
	}
	for (auto& block : nse.blocks) {
	// Example for dv_x/dx
		if (wall_type[POS(x + 1, y, z, globX, globY, globZ)] == 2) {
			dV.V11 = block.hmacro(MACRO::e_vx, x, y, z) 
				   - block.hmacro(MACRO::e_vx, x - 1, y, z);
		}
		else if (wall_type[POS(x - 1, y, z, globX, globY, globZ)] == 2) {
			dV.V11 = block.hmacro(MACRO::e_vx, x + 1, y, z) 
				   - block.hmacro(MACRO::e_vx, x, y, z);
		}
		else {
			dV.V11 = n1o2 * (block.hmacro(MACRO::e_vx, x + 1, y, z)
				   - block.hmacro(MACRO::e_vx, x - 1, y, z));
		}
	
	// Other components follow the same scheme, omitted for brevity...
	}
	return dV;
}
\end{lstlisting}

\subsection*{Shear rate calculation}
This function computes the shear rate $\dot{\gamma}$, defined by \ref{eq:dot gamma}, at a given point in the simulation domain.
\begin{lstlisting}[
	language=C++,
	caption={Implementation of the \texttt{dotGamma} function for shear rate calculation.},
	label={lst:dotGamma}]
real dotGamma(idx x, idx y, idx z)
{
	velocityGradient dV = calculateVelocityGradient(x, y, z);
	real shear_rate = sqrt(2) * sqrt(
		SQ(dV.V11) + SQ(dV.V12) + SQ(dV.V13) + SQ(dV.V21) + SQ(dV.V22) +
	    SQ(dV.V23) + SQ(dV.V31) + SQ(dV.V32) + SQ(dV.V33));

	return shear_rate;
}
\end{lstlisting}

\subsection*{Q-Criterion calculation}
This function calculates the Q-criterion, which is used to identify vortex structures in the simulation domain. The Q-criterion is defined as
\[
Q = \tfrac{1}{2} \left( \|\boldsymbol{\Omega}\|^{2} - ||\mathbf{D}||^{2} \right),
\]
where is the symmetric strain rate tensor and \(\boldsymbol{\Omega} = \frac{1}{2} \left[ \nabla \vec{u} - (\nabla \vec{u})^T \right],\) both obtained from the velocity gradient tensor \(\nabla \vec{u}\) \cite{Chong1990}. Regions where \(Q > 0\) indicate vorticity regions.
\begin{lstlisting}[
	language=C++,
	caption={Implementation of the \texttt{qCriterion} function for vortex structure identification.},
	label={lst:qCriterion}]
	real qCriterion(idx x, idx y, idx z)
	{
		velocityGradient dV = calculateVelocityGradient(x, y, z);
		// Symmetric part (strain rate tensor S)
		real S11 = dV.V11;
		real S12 = n1o2 * (dV.V12 + dV.V21);
		real S13 = n1o2 * (dV.V13 + dV.V31);
		real S22 = dV.V22;
		real S23 = n1o2 * (dV.V23 + dV.V32);
		real S33 = dV.V33;
		// Antisymmetric part (vorticity tensor Omega)
		real Omega12 = n1o2 * (dV.V12 - dV.V21);
		real Omega13 = n1o2 * (dV.V13 - dV.V31);
		real Omega23 = n1o2 * (dV.V23 - dV.V32);
		
		real normSqrS = SQ(S11) + no2 * NORM(S12, S13, S23) + SQ(S22)
		              + SQ(S33);
		real normSqrOmega = no2 * NORM(Omega12, Omega13, Omega23);
		
		return n1o2 * (normSqrOmega - normSqrS);
	}


\end{lstlisting}


\subsection*{Outflow calculation}
This function calculates the outflow at an outlet.
\begin{lstlisting}[
	language=C++,
	caption={Implementation of the \texttt{calculateOutflow} function for flow rate calculation.},
	label={lst:calculateOutflow}]
real calculateOutflow(idx outlet, bool isPositiveDirection)
{
	real Q_out = 0.0;
	int direction = isPositiveDirection ? no1 : -no1;
	
	for (idx y = 0; y < globY; y++) {
	for (idx z = 0; z < globZ; z++) {
		if (wall_type[POS(outlet, y, z, globX, globY, globZ)] != no2) {
			Q_out += direction * 
					 mean_vx[POS(outlet, y, z, globX, globY, globZ)];
		}
	}
	}
	
	return Q_out;
}
\end{lstlisting}
