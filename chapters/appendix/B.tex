\chapter{Custom Nelder-Mead algorithm implementation}\label{appendix B}

\section{Key features}

\subsection*{Initialization}
The simplex is initialized around the starting point \texttt{x\_start} using a defined step size. The function values for each vertex of the simplex are evaluated to initialize scores.

\subsection*{Stopping criteria}
The algorithm stops when:
\begin{itemize}
	\item The maximum number of iterations (\texttt{max\_iter}) is reached.
	\item The objective function improvement over consecutive iterations is below a defined threshold\\ (\texttt{no\_improve\_thr}) for a specified number of iterations (\texttt{no\_improv\_break}).
\end{itemize}

\subsection*{Function evaluations}
While the implementation is suboptimal in terms of the total number function evaluations, this design choice was made because, in the case specific for this work, a single function evaluation usually takes up to several hours. Thus, the algorithm prioritizes evaluating all candidate points (with potential parallelization) before making comparisons or updates to the simplex. This approach ensures that computational resources are utilized efficiently, even at the cost of additional function evaluations in some scenarios.

\section{The implementation}

The main part of the custom implementation is presented in Listing~\ref{lst:NM}. Full implementation is available upon request on Github at \href{https://github.com/buresjan/nelder-mead}{\texttt{https://github.com/buresjan/nelder-mead}}. The online code also includes several test cases showing the functionality of the custom implementation.

\newpage
\begin{lstlisting}[
	language=Python,
	caption={Main part of the custom Nelder-Mead algorithm implementation.  Full implementation is available upon request on Github at \href{https://github.com/buresjan/nelder-mead}{\texttt{https://github.com/buresjan/nelder-mead}}.},
	label={lst:NM}]
def nelder_mead(
	f,
	x_start,
	step=0.01,
	no_improve_thr=1e-8,
	no_improv_break=10,
	max_iter=100,
	delta_e=2.0,
	delta_oc=0.5,
	delta_ic=0.5,
	gamma=0.5,
):
	simplex, scores = initialize_simplex(f, x_start, step)
	prev_best = scores[0]
	no_improv = 0
	iter_count = 0
	
	while True:
		simplex, scores = order_simplex(simplex, scores)
		best = scores[0]
		
		# Check stopping criteria
		if max_iter and iter_count >= max_iter:
			return simplex[0], best
		if no_improv >= no_improv_break:
		return simplex[0], best
		
		iter_count += 1
		if best < prev_best - no_improve_thr:
			prev_best = best
			no_improv = 0
		else:
			no_improv += 1
		
		centroid = compute_centroid(simplex)
		candidates = generate_candidate_points(
			centroid, simplex[-1], delta_e, delta_oc, delta_ic
		)
		
		# Evaluate function values for candidate points
		f_r = f(candidates["reflection"])
		f_e = f(candidates["expansion"])
		f_oc = f(candidates["outside_contraction"])
		f_ic = f(candidates["inside_contraction"])
		
		# Apply the Nelder-Mead algorithm
		if scores[0] <= f_r < scores[-2]:  # Reflection
			simplex[-1] = candidates["reflection"]
			scores[-1] = f_r
			continue
		
		if f_r < scores[0]:  # Expansion
			if f_e < f_r:
				simplex[-1] = candidates["expansion"]
				scores[-1] = f_e
			else:
				simplex[-1] = candidates["reflection"]
				scores[-1] = f_r
				continue
		
		if f_r >= scores[-1]:  # Contraction
			if f_oc < scores[-1]:  # Outside contraction
				simplex[-1] = candidates["outside_contraction"]
				scores[-1] = f_oc
				continue
			if f_ic < scores[-1]:  # Inside contraction
				simplex[-1] = candidates["inside_contraction"]
				scores[-1] = f_ic
				continue
		
	simplex, scores = shrink_simplex(simplex, scores, gamma, f)
\end{lstlisting}